# 837. 新21点
**难度:Medium**
## 题目
原文链接：https://leetcode-cn.com/problems/new-21-game/

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：  
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。  
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

**示例 1：**
```
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
```
**示例 2：**
```
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
```
**示例 3：**
```
输入：N = 21, K = 17, W = 10
输出：0.73278
```

## 思路
* 好好理解下题目，谁能想到这是算爱丽丝赢的概率呢。。也就是一直抽牌直到和`≥K`,如果此时和`≤N`，则获胜，若`＞N`则失败
* dp算法
* dp[i] 表示从i开始抽牌时的胜率，最终是求dp[0]
* 因为最多只能抽到`[K, K+W-1]`的范围，在这个范围内，`≤N`的胜率为1， 否则为0
* 按理来说状态转移为： `dp[i]=1/w * (dp[i+1]+dp[i+2]+...+dp[i+w])`
* 但遍历时不需要每次都求和，只要把加上当前的状态（dp[i]）和减去之前最后一个状态（dp[i+w]）即可
## 代码
```python
class a837_Solution(object):

    def new21Game(self, N, K, W):
        """
        :type N: int
        :type K: int
        :type W: int
        :rtype: float
        """
        dp = [0]*(K+W)
        sum_ = 0. # 记录 W 个的状态和
        # “初始状态”
        for i in range(K, K+W):
            dp[i] = 1 if i <= N else 0
            sum_ += dp[i]
        # 状态转移
        for i in range(K-1, -1, -1):
            dp[i] = sum_/W
            sum_ = sum_ + dp[i] - dp[i+W]
        return dp[0]
```
