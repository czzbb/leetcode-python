# 133. 克隆图
**难度:Medium**
## 题目
原文链接：https://leetcode-cn.com/problems/clone-graph/

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。  
图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

测试用例格式：  
简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。  
邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。  
给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。

**示例 1：**
```
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```
**示例 2：**
```
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```
**示例 3：**
```
输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
```
**示例 4：**
```
输入：adjList = [[2],[1]]
输出：[[2],[1]]
```


## 思路
深拷贝，图的遍历

**方法一**
* **DFS**遍历
* 在遍历的过程中，需要记录下已经遍历过的节点，避免重复访问，陷入循环

**方法二**
* **BFS**遍历图
* 同DFS，要记录过已经访问过的节点
* 入队时，表示访问过该节点了；出队时遍历该节点的邻居
## 代码
**方法一**
```python
class a133_Solution:
    def __init__(self):
        self.visit = {}

    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        # 如果已经访问过的，则直接返回
        if node in self.visit:
            return self.visit[node]
        # 没访问过，创建新节点
        new_node = Node(node.val, [])
        # 在进行DFS前，要先标记该节点为访问过，否则可能会陷入循环中
        self.visit[node] = new_node
        for neighbor in node.neighbors: # DFS，这里append中也要是新创建的节点
            new_node.neighbors.append(self.cloneGraph(neighbor))
        return new_node
```
**方法二**
```python
class a133__Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        visit = {}
        #
        q = deque([node])
        n_node = Node(node.val, [])
        visit[node] = n_node
        while q:
            node = q.popleft()
            for neighbor in node.neighbors:
                if neighbor not in visit:
                    new_node = Node(neighbor.val, [])
                    visit[neighbor] = new_node
                    q.append(neighbor)
                visit[node].neighbors.append(visit[neighbor])
        return n_node
```
