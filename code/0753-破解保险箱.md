# 753. 破解保险箱
**难度:Hard**
## 题目
原文链接：https://leetcode-cn.com/problems/cracking-the-safe/

有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。  
你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。  
举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.  
请返回一个能打开保险箱的最短字符串。

**示例1:**
```
输入: n = 1, k = 2
输出: "01"
说明: "10"也可以打开保险箱。
```
**示例2:**
```
输入: n = 2, k = 2
输出: "00110"
说明: "01100", "10011", "11001" 也能打开保险箱。
```

## 思路
* 与[332. 重新安排行程](https://github.com/czzbb/leetcode-python/blob/master/code/0332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.md)相同，一笔画的问题
* **Hierholzer**算法：该算法会**一次遍历所有的点、所有的边**
  1. 对每个点（从初始点开始），`dfs`遍历其所有相邻的点
  2. 在遍历时，删除该边
  3. 遍历所有边后，该**点**入栈/遍历完边后，将**边**入栈(本题是将边入栈，332是将点入栈)
  4. 由于是遍历完后入栈，因此最终答案要反转。
* 这里每个节点为 `n-1` 位的值，边为`[0, k-1]`，因此`节点+边`就构成了一个可能的解
* 共`k**(n-1)`个节点，每个节点`k`条入边，`k`条出边，因此共`k**n`条边，即所有可能的解
* 一次遍历完所有的边即为答案

## 代码
```python
class a753_Solution:
    def crackSafe(self, n: int, k: int) -> str:
        def dfs(node):
            # 对每个节点，遍历其相邻的边
            for i in range(k):
                next_ = node * 10 + i  # 该节点的某条边，共 n 位
                if next_ not in seen:  # 这条边没遍历过
                    seen.add(next_)  # 删除边
                    dfs(next_ % highest)  # 遍历，这里只要 n-1位，
                    ans.append(str(i))  # 入栈

        ans = []
        seen = set()
        highest = 10 ** (n - 1)  # 节点状态的最大值，节点是 n-1 位
        dfs(0) # 从0开始遍历
        ans.reverse()  # 反转
        return '0' * (n - 1) + ''.join(ans)
```
