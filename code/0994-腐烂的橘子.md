# 994. 腐烂的橘子
**难度:easy**
## 题目
原文链接：https://leetcode-cn.com/problems/rotting-oranges/

在给定的网格中，每个单元格可以有以下三个值之一：

* 值 0 代表空单元格；
* 值 1 代表新鲜橘子；
* 值 2 代表腐烂的橘子。
* 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

**示例 1：**
```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```
**示例 2：**
```
输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
```
**示例 3：**
```
输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```
## 思路
* 就按着常识写。。干就完了。
* 硬要说的话，可以叫：多源广度优先搜索

## 代码
```python
class a994_Solution(object):
    def orangesRotting(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m, n = len(grid), len(grid[0]) # 高，宽
        stack = [[y, x] for y in range(m) for x in range(n) if grid[y][x]==2]# 记录腐烂橘子的坐标
        direction = [[-1,0],[1,0],[0,-1],[0,1]] # 上下左右四个方向
        minute = 0

        while True:
            stack_next = []
            while stack:
                y, x = stack.pop()
                for d in direction:
                    y_new, x_new = y+d[0], x+d[1]
                    if -1<y_new<m and -1<x_new<n and grid[y_new][x_new] == 1:#如果四周有新鲜橘子
                        grid[y_new][x_new] = 2
                        stack_next.append([y_new, x_new])
            if not stack_next: break
            stack = stack_next
            minute += 1
        #
        for i in grid:
            if 1 in i:
                return -1
        return minute
```
