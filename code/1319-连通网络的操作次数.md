# 1319. 连通网络的操作次数
**难度:Medium**
## 题目
原文链接：https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/

用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。  
网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。  
给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 

**示例 1：**
```
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
```
**示例 2：**
```
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2
```
**示例 3：**
```
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
输出：-1
解释：线缆数量不足。
```
**示例 4：**
```
输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
输出：0
```

## 思路
* 并查集
* 先遍历一次，之后得到
* 1.并查集中集合的个数，2.冗余线的个数（当一条线的两个节点在同个集合中，该线是冗余的）
* 当 `线的个数-1 < 集合的个数时`，不能合并；否则返回 `集合的个数-1`

## 代码
```python
class unionfind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.cnt = n  # 并查集中集合的个数
        self.dummy = 0  # 冗余线的个数

    def find(self, x):
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            self.dummy += 1
        else:
            self.cnt -= 1
            self.parent[px] = py
class a1319_Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        uf = unionfind(n)
        for x, y in connections:
            uf.union(x, y)
        if uf.dummy + 1 < uf.cnt: return -1
        return uf.cnt - 1
```
