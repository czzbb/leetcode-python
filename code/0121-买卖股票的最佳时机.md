# 121. 买卖股票的最佳时机
**难度:easy**
## 题目
原文链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。  
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。  
注意你不能在买入股票前卖出股票。

**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**示例 2:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

## 股票6问的总体思路
* 股票6问可以统一使用**DP算法**一网打尽！
* 处理股票问题的顺序：121--122--309--714--123--188
* 我们定义状态*dp[i][k][0/1]* 表示第*i+1*天，**最多**交易k次（实际≤k），无/有股票
* 买入的时候算交易+1（定义卖出时+1也可）
* 则状态转移方程为,一共 **2*k个状态转移方程**
  ```python
  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]   + prices[i])
  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
  ```
* 初始状态：初始化**所有的k**
  ```python
  dp[0][k][0] = 0  #第一天没买，资产为0
  dp[0][k][1] = -prices[0]  #第一天买了，资产为-prices[0]
  ```
## 本题思路
* 本题中k最大为1，因此状态转移方程为
  ```python
  dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1]   + prices[i])
  dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
  ```
* 又因为*dp[i-1][0][0]=0*, 因此上述方程中k都为1，状态因此与k无关，可得
  ```python
  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
  dp[i][1] = max(dp[i-1][1],  - prices[i])
  ```
* 至此本题已解决，我们发现该DP问题中只设计相邻状态间的转换（即第i+1天只与第i天有关），因此只需维护一天的状态，使用inplace操作以达到节省空间的目的
## 代码
```python
class a121_Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if not prices:
            return 0
        dp_i_0 = 0            # 第一天不买的情况
        dp_i_1 = -prices[0]   # 第一天买的情况
        for i in range(1,len(prices)):
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i])
            dp_i_1 = max(dp_i_1,-prices[i])
        return dp_i_0
```
